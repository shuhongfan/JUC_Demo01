package com.shf14JMM;

import com.shf.tvolatile.VDemo02;
import org.junit.Test;

import java.util.concurrent.TimeUnit;

import static com.shf.tvolatile.VDemo02.add;

/**
 * 请你谈谈你对Volatile的理解
 * Volatile是java虚拟机提供 轻量级的同步机制
 * 1.保证 可见性
 * 2.不保证原子性（不可分割）
 * 3.禁止指令重排
 *      什么是指令重拍？你写的程序，计算机并不是按照你写的那样取执行的
 *      源代码---》编译器优化的重排--》指令并行也可能会重排--》内存系统也会重排--》执行
 *      Volatile是可以保持 可见性。不能保证原子性，由于内存屏障，可以保证避免指令重拍的现象产生！
 *      在单例模式使用得最多
 * 什么是JMM？
 * JMM：java内存模型，不存在的东西，概念！约定！
 *
 * 关于JMM的一些同步约定：
 * 1.线程解锁前，必须把共享变量 立刻 刷回主存
 * 2.线程加锁前，必须读取主存中的最新值到工作内存中
 * 3.加锁和解锁是同一把锁
 *
 * 主内存与工作内存八种操作指令：
 * lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态；
 * unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；
 * read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；
 * load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中；
 * use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作；
 * assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；
 * store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用；
 * write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；
 * 如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
 *
 * 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现；
 * 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存；
 * 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中；
 * 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或 assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作；
 * 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执 行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁；
 * 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值；
 * 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量；
 * 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）；
 */
public class Demo01 {
//    不加 volatile程序就会死循环
//    加volatile可以保证可见性
    private volatile static int num = 0;

    public static void main(String[] args) {
        new Thread(()->{ //线程1
            while(num == 0){

            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        num=1;
        System.out.println(num);
    }
}
